#include "sitronix_i2c_touch.h"

extern int st_i2c_write_bytes(u8* txbuf,int len);
extern int st_i2c_read_bytes(u8 addr,u8 *rxbuf,int len);

#ifdef ST_TEST_RAW
st_int st_drv_Get_2D_Length(st_int tMode[])
{
	if(tMode[0] ==0)
		return tMode[1];
	else
		return tMode[2];
}
st_int st_drv_Get_2D_Count(st_int tMode[])
{
	if(tMode[0] == 0)
		return tMode[2];
	else
		return tMode[1];
}

#ifdef ST_RAWTEST_LOGFILE
st_int st_drv_Get_2D_RAW(st_int tMode[],st_int rawJ[],st_int gsMode,st_u8 *rtbuf,struct file *filp)
#else
st_int st_drv_Get_2D_RAW(st_int tMode[],st_int rawJ[],st_int gsMode,st_u8 *rtbuf)
#endif /* ST_RAWTEST_LOGFILE */
{
	st_int count =st_drv_Get_2D_Count(tMode);
	st_int length = st_drv_Get_2D_Length(tMode);
	st_int maxTimes = 60;
	st_int dataCount=0;
	st_int times = maxTimes;
	st_int readLength = 8 + 2*length;	
	st_u8 raw[0x40];
	st_int i=0;
	st_int index;
	st_int keyAddCount = (tMode[3] >0)? 1:0;
	short rawI;
	st_int errorCount = 0;	
	st_u8 isFillData[MAX_SENSOR_COUNT];
#ifdef ST_RAWTEST_LOGFILE
	char data1[80];
#endif
	memset(isFillData,0,count+keyAddCount);
	memset(raw,0,0x40);

	//sterr("isFill 0 : %d",isFillData[0]);
	while(dataCount != (count+keyAddCount) && times-- >0)
	{	
		st_i2c_read_bytes(0x40,raw,readLength);
		//sterr("%X %X %X data:%d key:%d",raw[0],raw[1],raw[2],dataCount,tMode[3]);
		if(raw[0] == 6)
		{
			index = raw[2];
			//sterr("isFill %d : %d %d , %d",index,isFillData[index],dataCount,count+keyAddCount);
			if(isFillData[index] ==0)
			{	
				//sterr("index %d",index);			
				isFillData[index] = 1;
				dataCount++;
				//index = index*length;
				if(index !=0)
				{	for(i=0;i<length;i++)
					{
						if(index == 1 && (i == 0 || i == 6 || i == 12))
						{}else{
						rawI = (short)((raw[4+2*i])*0x100 + raw[5+2*i]);					
						//sterr("Sensor RAW %d,%d = %d",index,i,rawI);
						if(rawI > MAX_RAW_LIMIT || rawI  < MIN_RAW_LIMIT)
						{
							sterr("Error: Sensor RAW %d,%d = %d out of limity (%d,%d)",index,i,rawI,MIN_RAW_LIMIT,MAX_RAW_LIMIT);
#ifdef ST_RAWTEST_LOGFILE
							snprintf(data1,80,"Error: Sensor RAW %d,%d = %d out of limity (%d,%d)\n",index,i,rawI,MIN_RAW_LIMIT,MAX_RAW_LIMIT);
							filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);			
#endif
							rtbuf[index*length + i] = 1;
							errorCount++;
						}
						//rawI[index+i] = raw[4+2*i]*0x100 + raw[5+2*i];
						}
					}
				}
			}
		}
		else if(raw[0]==7)
		{
			//key
			stinf("key");
			if(isFillData[count] ==0)
			{	
				isFillData[count] = 1 ;				
				dataCount++;
				for(i=0;i<tMode[3];i++)
				{
					rawI = (short)((raw[4+2*i])*0x100 + raw[5+2*i]);
					//sterr("Key RAW %d = %d",i,rawI);
					if(rawI > MAX_RAW_LIMIT || rawI  < MIN_RAW_LIMIT)
					{
						sterr("Error: Key RAW %d = %d out of limity (%d,%d)",i,rawI,MIN_RAW_LIMIT,MAX_RAW_LIMIT);
#ifdef ST_RAWTEST_LOGFILE
						snprintf(data1,80,"Error: Key RAW %d = %d out of limity (%d,%d)\n",i,rawI,MIN_RAW_LIMIT,MAX_RAW_LIMIT);
						filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
						rtbuf[count*length + i] = 1;
						errorCount++;
					}
					//rawI[count*length+i] = raw[4+2*i]*0x100 + raw[5+2*i];
					
				}
			}
		}		
	}
	
	if(times <=0)
	{
		sterr("Get 2D RAW fail!");
		return -1;
	}
	return errorCount;
}

struct CommandIoPacket{
unsigned char CmdID;
unsigned char ValidDataSize;
unsigned char CmdData[30];
};

void STChecksumCalculation(unsigned short *pChecksum, unsigned char *pInData, unsigned long Len){
	unsigned long i;
	unsigned char LowByteChecksum;
	for(i = 0; i < Len; i++)
	{
		*pChecksum += (unsigned short)pInData[i];
		LowByteChecksum = (unsigned char)(*pChecksum & 0xFF);
		LowByteChecksum = (LowByteChecksum) >> 7 | (LowByteChecksum) << 1;
		*pChecksum = (*pChecksum & 0xFF00) | LowByteChecksum;
	}
}

bool TDU_SetH2DReady(void){
	int ret;
	bool bRet = false;
	unsigned char buf[2];
	buf[0] = 0xF8;
	buf[1] = 0x01;
	ret = st_i2c_write_bytes(buf, 2);
	//ret = WriteI2CReg(&tmp, 0xF8, 1);
	if(ret <= 0) {
		sterr("TDU_SetH2DReady: write ready error.\n");
		bRet = false;
	}
	else{
		bRet = true;
	}
	return bRet;
}

bool TDU_GetH2DReady(void){
	bool bRet = false;
	unsigned char tmp = 0xff;
	int ret, retry = 0;
	do{
		msleep(1);
		ret = st_i2c_read_bytes(0xF8,&tmp,1);
		//sterr("tmp  %x\n",tmp);
		//ret = ReadI2CReg(&tmp, 0xF8, 1);
		if(ret <= 0) {
			stinf("TDU_GetH2DReady: retry(%d) read ready.\n", retry++);
		}
	        else{
	            if(tmp == 0x01){
	                //processing command, retry
	                stinf("retry  ............\n");
	                retry = 0;
	                continue;            
	            }
        	}
		if(retry > 1000){
			sterr("TDU_GetH2DReady: time out \n");
			//break;
			bRet = false;
			return bRet;
		}
		
	}while(ret <= 0);

	if(tmp == 0x00){	//OK
		bRet = true;
	}
	else if(tmp == 0x80){
		sterr("TDU_ReadIOCommand: Unknown Command ID.\n");
		bRet = false;
	}
	else if(tmp == 0x81){
		sterr("TDU_ReadIOCommand: Host to device command checksum error.\n");
		bRet = false;
	}
	else{
		sterr("Unknown Error(0x%02X).\n", tmp);
		bRet = false;
	}
	return bRet;
}


bool TDU_ReadIOCommand(struct CommandIoPacket *packet){
	bool bRet = false;
	int ret;
	unsigned char tmp[32];
	//process commmand
	memset(tmp, 0, 32);
	ret = st_i2c_read_bytes(0xD0,tmp,32);//st_u8 addr, st_u8 *rxbuf, int len)
	//ret = ReadI2CReg(tmp, 0xD0, 32);
	if(ret <= 0) {
		sterr("TDU_ReadIOCommand: read packet error.\n");
		bRet = false;
	}
	else{
		memcpy((void *)packet, (const void *)tmp, 32);
		bRet = true;
	}
	return bRet;
}

bool TDU_WriteIOCommand(struct CommandIoPacket *packet){
	bool bRet = false;
	int ret;
	unsigned char tmp[33];
	
	memset(tmp, 0x00, 33);	
	memcpy((void *)tmp+1, (const void *)packet, 32);
	
	tmp[0] = 0xD0;
	ret = st_i2c_write_bytes(tmp, 33);
	//ret = WriteI2CReg(tmp, 0xD0, 32);
	if(ret <= 0) {
		sterr("TDU_WriteIOCommand: write packet error.\n");
		bRet = false;
	}
	else{
		bRet = true;
	}

	return bRet;
}

int TDU_CmdioRead(int type,int address, unsigned char *buf, int len){
	int getLen = 0, offset = 0;
	struct CommandIoPacket outPacket;
	struct CommandIoPacket inPacket;
	int remain = len;
	int pktDataSize = 0;
	unsigned short chksum, vchksum; 
	int retry=0;
	
	do{
		pktDataSize = (remain > 24)? 24: remain;
		outPacket.CmdID = 0x02;	//read RAM/ROM
		outPacket.ValidDataSize = 5 ;
		outPacket.CmdData[0] = type;	//RAM
		outPacket.CmdData[1] = (((address + offset) >> 8 ) & 0xFF);	//high byte
		outPacket.CmdData[2] = (((address + offset)) & 0xFF);		//low byte
		outPacket.CmdData[3] = pktDataSize;
		chksum = 0;
		STChecksumCalculation(&chksum, (unsigned char *)&outPacket, 6);
		outPacket.CmdData[4] =(chksum & 0xFF) ;
		//sterr("add = %x, size = %d ", (address + offset), pktDataSize);
		//sterr("add[0] = %x,add[1] = %x,\n", outPacket.CmdData[1], outPacket.CmdData[2]);

		if(!TDU_WriteIOCommand(&outPacket)){
			sterr("TDU_CmdioRead: (E)TDU_WriteIOCommand.\n");
			return getLen;
		}
		if(!TDU_SetH2DReady()){
			sterr("TDU_CmdioRead: (E)TDU_SetH2DReady.\n");
			return getLen;
		}
		if(!TDU_GetH2DReady()){
			sterr("TDU_CmdioRead: (E)TDU_GetH2DReady.\n");
			return getLen;
		}
		if(!TDU_ReadIOCommand(&inPacket)){
			sterr("TDU_CmdioRead: (E)TDU_ReadIOCommand.\n");
			return getLen;
		}

		if(inPacket.CmdID == 0x82 
			&& inPacket.CmdData[0] == type){
			vchksum = 0;
			STChecksumCalculation(&vchksum, (unsigned char *)&inPacket, inPacket.ValidDataSize + 1);
			vchksum = (vchksum & 0xFF);
			if(vchksum == inPacket.CmdData[inPacket.ValidDataSize -1]){
				memcpy(buf+offset, &(inPacket.CmdData[2]), inPacket.CmdData[1]);
				remain -= inPacket.CmdData[1];	//data size
				offset += inPacket.CmdData[1];
				getLen += inPacket.CmdData[1];
			}
			else{
				//drop packet
				sterr("Invalid Cheksum Expect(0x%02x) Get(0x%02X)\n", vchksum, inPacket.CmdData[inPacket.ValidDataSize -1]);
			}
			retry = 0;
		}
		else{
			//drop packet
			sterr("Unexpect CmdID (0x%02x) or Type (0x%02X)\n", inPacket.CmdID, inPacket.CmdData[0]);
			retry ++;
			if(retry > 10)
				return -1;
		}
		
	}while(remain > 0);	
	return getLen;
	
}

int TDU_CmdioWrite(int type,int address, unsigned char *buf, int len){
	int setLen = 0, offset = 0;
	struct CommandIoPacket outPacket;
	//CommandIoPacket inPacket;
	int remain = len;
	int pktDataSize = 0;
	unsigned short chksum;//, vchksum; 
	
	do{
		pktDataSize = (remain > 24)? 24: remain;
		outPacket.CmdID = 0x01;	//write RAM/ROM
		outPacket.ValidDataSize = pktDataSize + 5 ;
		outPacket.CmdData[0] = type;	
		outPacket.CmdData[1] = (((address + offset) >> 8 ) & 0xFF);	//high byte
		outPacket.CmdData[2] = (((address + offset)) & 0xFF);		//low byte
		outPacket.CmdData[3] = pktDataSize;
		memcpy((void *)&(outPacket.CmdData[4]), (const void *)(buf+offset), pktDataSize);
		chksum = 0;
		STChecksumCalculation(&chksum, (unsigned char *)&outPacket, outPacket.ValidDataSize + 1);
		outPacket.CmdData[ outPacket.ValidDataSize -1 ] =(chksum & 0xFF) ;
		//sterr("outPacket.CmdData[1] outPacket.CmdData[2] %x %x\n",outPacket.CmdData[1],outPacket.CmdData[2]);
		if(!TDU_WriteIOCommand(&outPacket)){
			sterr("TDU_SetDeviceRam: (E)TDU_WriteIOCommand.\n");
			return setLen;
		}
		if(!TDU_SetH2DReady()){
			sterr("TDU_SetDeviceRam: (E)TDU_SetH2DReady.\n");
			return setLen;
		}
		//check processing result
		if(!TDU_GetH2DReady()){
			sterr("TDU_SetDeviceRam: (E)TDU_GetH2DReady.\n");
			return setLen;
		}
		else{
			//processing write command OK
			remain -= pktDataSize;	
			offset += pktDataSize;
			setLen += pktDataSize;
		}

	}while(remain > 0);

	return setLen;
}
#define ST_SHORT_TEST_IS_1T2R		1
#define ST_SHORT_TEST_CFG_OFFSET	0xEFC0
unsigned char st_short_test_cfg[] = {\
0x43,0x46,0x54,0x31,0x08,0x38,0x24,0x24,0x0C,0x00,0x08,0x3C,0x02,0x6E,0x00,0x1E,\
0x01,0x3D,0x01,0x65,0x01,0x97,0x01,0xA5,0x01,0xFD,0x02,0x52,0x00,0x00,0x01,0x33,\
0x55,0x2D,0x46,0x00,0x00,0x00,0x1A,0x36,0x40,0x40,0x00,0x53,0x0C,0x2D,0x45,0x00,\
0x00,0x00,0x1F,0x40,0x40,0x40,0x00,0x2D,0x3E,0x2D,0x43,0x00,0x00,0x00,0x1B,0x36,\
0x40,0x40,0x00,0x54,0x0B,0x2D,0x3C,0x00,0x00,0x00,0x20,0x3F,0x40,0x40,0x00,0x4C,\
0x15,0x2D,0x37,0x00,0x00,0x00,0x1D,0x3A,0x40,0x40,0x00,0x44,0x1F,0x2D,0x31,0x00,\
0x00,0x00,0x1B,0x35,0x40,0x40,0x00,0x34,0x34,0x2D,0x2C,0x00,0x00,0x00,0x1A,0x33,\
0x40,0x40,0x00,0x32,0x37,0x2D,0x28,0x00,0x00,0x00,0x1B,0x35,0x40,0x40,0x00,0x35,\
0x33,0x2D,0x1E,0x00,0x00,0x00,0x1A,0x34,0x40,0x40,0x00,0x33,0x35,0x2D,0x12,0x00,\
0x00,0x00,0x1A,0x34,0x40,0x40,0x00,0x36,0x32,0x2D,0x0C,0x00,0x00,0x00,0x1A,0x34,\
0x40,0x40,0x00,0x28,0x45,0x2D,0x00,0x00,0x00,0x00,0x1C,0x39,0x40,0x40,0x00,0x00,\
0x44,0x07,0x81,0x00,0x0A,0x03,0x00,0x14,0x24,0x00,0x00,0x03,0x98,0x00,0x00,0x00,\
0x03,0x11,0x27,0x70,0x80,0x75,0x75,0x00,0x28,0x00,0x00,0x13,0x05,0x00,0x04,0x01,\
0x00,0x01,0x00,0x01,0x00,0x01,0x03,0x00,0x00,0x01,0x01,0x00,0x02,0x00,0x00,0x00,\
0x00,0x00,0x33,0x00,0x02,0x43,0x10,0x24,0x00,0x55,0x57,0x00,0x05,0x00,0x00,0x01,\
0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0B,0x0A,0x0D,0x0C,0x0F,0x0E,0x11,\
0x10,0x13,0x12,0x15,0x14,0x17,0x16,0x19,0x18,0x1B,0x1A,0x1D,0x1C,0x1F,0x1E,0x21,\
0x20,0x23,0x22,0x01,0x00,0x03,0x02,0x05,0x04,0x07,0x06,0x09,0x08,0x0B,0x0A,0x0D,\
0x0C,0x0F,0x0E,0x11,0x10,0x13,0x12,0x00,0x00,0x21,0x51,0x00,0x72,0x52,0x97,0x03,\
0x00,0x88,0x44,0x10,0x00,0x00,0x96,0x00,0x00,0x00,0x00,0x80,0xB0,0x00,0x00,0x00,\
0x00,0x03,0x55,0x66,0x02,0xD0,0x05,0xA0,0x0A,0x01,0x00,0x00,0x19,0x10,0x00,0x3C,\
0x08,0x82,0x3C,0x62,0x21,0x00,0x04,0x04,0x03,0x05,0x85,0x00,0x0A,0x10,0x03,0x0C,\
0x00,0x92,0x00,0x05,0x80,0x13,0x05,0x5A,0xB4,0x40,0x00,0x00,0x20,0x3A,0x04,0x64,\
0x32,0x00,0x00,0xFF,0xFD,0x18,0x18,0x02,0xD0,0x05,0xA0,0x00,0x00,0x00,0x00,0x03,\
0x04,0x28,0x00,0xC0,0x3C,0x28,0x28,0x46,0x80,0x40,0x14,0x02,0x03,0x32,0x00,0x00,\
0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x97,0x34,0x1E,0x80,0x23,0x75,0x75,0x43,0x10,\
0x0A,0x00,0xFA,0x00,0x46,0x05,0x00,0x64,0x26,0x03,0x20,0xFF,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x10,0x00,0x3C,0x48,0x1E,0x19,0x07,0x05,0x00,0x00,0x00,0x2D,\
0x00,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x20,0x00,0x00,0x00,0x00,0x02,\
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x61,0x4B,0x69,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x05,0x04,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9A,\
0x00,0x9A,0x00,0x9A,0x00,0x01,0x00,0x03,0x00,0x06,0x00,0x0A,0x00,0x0F,0x00,0x15,\
0x00,0x1C,0x00,0x24,0x00,0x2D,0x00,0x37,0x00,0x42,0x00,0x4E,0x00,0x5B,0x00,0x69,\
0x00,0x78,0x00,0x88,0x00,0x99,0x00,0xAB,0x00,0xBE,0x00,0xD2,0x00,0xE7,0x00,0xFD,\
0x01,0x14,0x01,0x2C,0x01,0x45,0x01,0x5F,0x01,0x7A,0x01,0x96,0x01,0xB3,0x01,0xD1,\
0x01,0xF0,0x02,0x10,0x02,0x31,0x02,0x53,0x02,0x76,0x02,0x9A,0x02,0xBF,0x02,0xE5,\
0x03,0x0C,0x03,0x34,0x03,0x5D,0x03,0x87,0x03,0xB2,0x03,0xDE,0x04,0x0B,0x04,0x39,\
0x04,0x68,0x04,0x98,0x04,0xC9,0x04,0xFB,0x05,0x2E,0x05,0x62,0x05,0x97,0x05,0xCD,\
0x06,0x04,0x06,0x3C,0x06,0x75,0x06,0xAF,0x06,0xEA,0x07,0x26,0x07,0x63,0x07,0xA1,\
0x07,0xE0,0x08,0x20,0x08,0x61,0x08,0xA3,0x08,0xE6,0x09,0x2A,0x09,0x6F,0x09,0xB5,\
0x09,0xFC,0x0A,0x44,0x0A,0x8D,0x0A,0xD7,0x0B,0x22,0x0B,0x6E,0x0B,0xBB,0x0C,0x09,\
0x0C,0x58,0x0C,0xA8,0x0C,0xF9,0x0D,0x4B,0x0D,0x9E,0x0D,0xF2,0x0E,0x47,0x0E,0x9D,\
0x0E,0xF4,0x0F,0x4C,0x0F,0xA5,0x0F,0xFF,0x10,0x5A,0x10,0xB6,0x11,0x13,0x11,0x71,\
0x11,0xD0,0x12,0x30,0x12,0x91,0x12,0xF3,0x13,0x56,0x13,0xBA,0x14,0x1F,0x14,0x85,\
0x14,0xEC,0x15,0x54,0x15,0xBD,0x16,0x27,0x16,0x92,0x16,0xFE,0x17,0x6B,0x17,0xD9,\
0x18,0x48,0x18,0xB8,0x19,0x29,0x19,0x9B,0x1A,0x0E,0x1A,0x82,0x1A,0xF7,0x1B,0x6C,\
0x1B,0xE1,0x1C,0x56,0x1C,0xCB,0x1D,0x40,0x1D,0xB5,0x1E,0x2A,0x1E,0x9F,0x1F,0x14,\
0x1F,0x89,0x1F,0xFE,0x20,0x73,0x20,0xE8,0x21,0x5D,0x21,0xD2,0x22,0x47,0x22,0xBC,\
0x23,0x31,0x23,0xA6,0x24,0x1B,0x24,0x90,0x25,0x05,0x25,0x7A,0x25,0xEF,0x26,0x64,\
0x26,0xD9,0x27,0x4E,0x27,0xC3,0x28,0x38,0x28,0xAD,0x29,0x22,0x29,0x97,0x2A,0x0C,\
0x2A,0x81,0x2A,0xF6,0x2B,0x6B,0x2B,0xE0,0x2C,0x55,0x2C,0xCA,0x2D,0x3E,0x2D,0xB1,\
0x2E,0x23,0x2E,0x94,0x2F,0x04,0x2F,0x73,0x2F,0xE1,0x30,0x4E,0x30,0xBA,0x31,0x25,\
0x31,0x8F,0x31,0xF8,0x32,0x60,0x32,0xC7,0x33,0x2D,0x33,0x92,0x33,0xF6,0x34,0x59,\
0x34,0xBB,0x35,0x1C,0x35,0x7C,0x35,0xDB,0x36,0x39,0x36,0x96,0x36,0xF2,0x37,0x4D,\
0x37,0xA7,0x38,0x00,0x38,0x58,0x38,0xAF,0x39,0x05,0x39,0x5A,0x39,0xAE,0x3A,0x01,\
0x3A,0x53,0x3A,0xA4,0x3A,0xF4,0x3B,0x43,0x3B,0x91,0x3B,0xDD,0x3C,0x27,0x3C,0x6F,\
0x3C,0xB5,0x3C,0xF9,0x3D,0x3B,0x3D,0x7B,0x3D,0xB9,0x3D,0xF5,0x3E,0x2F,0x3E,0x67,\
0x3E,0x9D,0x3E,0xD1,0x3F,0x03,0x3F,0x33,0x3F,0x61,0x3F,0x8D,0x3F,0xB7,0x3F,0xDF,\
0x40,0x05,0x40,0x29,0x40,0x4B,0x40,0x6B,0x40,0x89,0x40,0xA5,0x40,0xBF,0x40,0xD7,\
0x40,0xED,0x41,0x01,0x41,0x13,0x41,0x23,0x41,0x31,0x41,0x3D,0x41,0x47,0x41,0x4F,\
0x41,0x55,0x41,0x59,0x41,0x5B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA8,0x80\
};

int Get1DRaw(bool fSelectTXMode,int nRawData[])
{
	unsigned char mutBuf[0xFF];
	int count =0;
	int maxtime = 0;
	int id;
	mutBuf[0] = 0xF1;
	mutBuf[1] = 0xC0;
	
	st_i2c_write_bytes(mutBuf, 2);
	
	//mutBuf[0] = 0xF1;
	//mutBuf[1] = 0xD0;
	
	//st_i2c_write_bytes(mutBuf, 2);
	
	while(count < 5 && maxtime++ < 1000)
	{
		//msleep(20);
		st_i2c_read_bytes(0x40, mutBuf, 0x50);
		//if(mutBuf[0] ==0x04)
		//	sterr("04 %x %x %x\n",mutBuf[1],mutBuf[2],mutBuf[3]);
			
		
		//if( ((!fSelectTXMode) && (mutBuf[0] ==0x04) &&  (mutBuf[1] ==0x4b) &&  (mutBuf[2] ==0x00) &&  (mutBuf[3] ==0x00)) 
		//  || ((fSelectTXMode) && (mutBuf[0] ==0x04) &&  (mutBuf[1] ==0x2b) &&  (mutBuf[2] ==0x02) &&  (mutBuf[3] ==0x24)))
		if( ((!fSelectTXMode) && (mutBuf[0] ==0x04) &&  (mutBuf[2] ==0x00) &&  (mutBuf[3] ==0x00)) 
		  || ((fSelectTXMode) && (mutBuf[0] ==0x04) &&  (mutBuf[2] ==0x02)))
		{
			count++;
			if(count == 5)
			{
				for(id=0; id<(36); id++){
					if(mutBuf[4+2*id] & 0x80)
						nRawData[id] = ((mutBuf[4+2*id]<<8) + mutBuf[5+2*id]) - 65536;					           				
					else
           					nRawData[id] = ((mutBuf[4+2*id]<<8) + mutBuf[5+2*id]);					           				
       			 	}
			}
		}		
	}
	
	if(count >=5)
		sterr("Get 1d RAW ok %d %d %d %d %d %d %d %d\n",nRawData[0],nRawData[1],nRawData[2],nRawData[3],nRawData[4],nRawData[5],nRawData[6],nRawData[7]);
	else
		sterr("Get 1d RAW fail\n");
	return (count>=5)?0:-1;
}

void WriteFilterRam(void)
{
    //FilterRam        
    unsigned char pFilterRam[2]={0x00,0x30};
    unsigned char pCMDData[1024]={0};
    int i;
    for(i=0;i<1024;i++){
        if((i%2)==0){
            pCMDData[i] = pFilterRam[0];
        }else{
            pCMDData[i] = pFilterRam[1];
        }
    }
    TDU_CmdioWrite(3,0,pCMDData,0x9A);
    //theApp.TDU_SetDeviceAFE_Ram(0x00,pCMDData,0x9A);
}

void WriteTestCFG(void)
{
	unsigned char buf[8];

	TDU_CmdioWrite(2, ST_SHORT_TEST_CFG_OFFSET, st_short_test_cfg, sizeof(st_short_test_cfg));

	/* #DoPower Down Wake Up */
	buf[0] = 0x2;
	buf[1] = 0x2;
	st_i2c_write_bytes(buf, 2);

	msleep(150);
	buf[0] = 0x2;
	buf[1] = 0x0;
	st_i2c_write_bytes(buf, 2);

	msleep(150);

	WriteFilterRam();
}

int RunFindShortStart(bool fSelectTXMode,int xNum, int yNum,unsigned char pMaxPatternCount)
{	
	int nScanChannel = 0;
	
	int nMaxShortRecordRaw=0;
	int nShortMaxRawDefine = 0;
	unsigned char pTX_OSB=0x03,pRX_OSB=0x03;
	unsigned char pShortSkipArray[40]={0};
	
	int nMaxRx = xNum=36;
	int nMaxTx = yNum=20;	
	
	//unsigned char pOrgRxChannelMapping[40],pOrgTxChannelMapping[40];
	bool fMayBeFilterRamError=false;
	int nRet = 1,pMutulRaw[40];
	//unsigned char pResult[40*40]={0};
	unsigned char pCMDData[64]={0};
	unsigned char Pattern[13][5];//={0};
	unsigned char pListArray[13][37]={
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
        {0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1},
        {0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1},
        {0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0},
        {0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0},
        {0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0}
   	};
	unsigned char pSkipArray[37]={0};
	unsigned char pTempArray_1[37]={0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1};
	unsigned char pTempArray_2[37]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
	
	unsigned char buf[8];
	int nSum=0;
	int i,j;
	
	int nTxStartRun=0;
	int nRun;
        
	unsigned char fFindShort=false;
	int nRaw =0;
	
	int nAddTx=0;
	bool fFind=false;
	int nCheckStart=0;
	/////////////////////
	//////////// start work
	if(fSelectTXMode)
        	nScanChannel = yNum;
	else
		nScanChannel = xNum;	
			
	if(fSelectTXMode){
        	nScanChannel = nMaxTx;
	}else{
        	nScanChannel = nMaxRx;
	}
	
	if(fSelectTXMode==false){     
        	memcpy(pSkipArray,pTempArray_1,37);   
	}else{
        	
		memcpy(pSkipArray,pTempArray_2,37);         
	}
	
	for(i=1;i<13;i++){
        	for(j=0;j<36;j++){    
			if(pSkipArray[j]==1){
				pListArray[i][j] = 1;
			}
		}
	}
	
	//memset(pResult,1,40*40);
	for(i=0;i<13;i++)
	{
        	nSum=0;
        	for(j=0;j<37;j++)
        	{            	            	
	            	nSum += ((pListArray[i][j]) << (j%0x08));
	            	if((j+1)%8==0){
	                	Pattern[i][j/8] = nSum;
	                	nSum = 0;
	            	}            
        	}
        	Pattern[i][37/8] = nSum+0x20;
    	}

	 //Get RxChannelMapping from flash    
	//memcpy(pOrgRxChannelMapping,pST1802CFG.AFE_RX_TAB,0x24);
	//memcpy(pOrgTxChannelMapping,pST1802CFG.AFE_TX_TAB,0x14);   

	//#Do Write PRAM (TestCFG.bin)
	//sterr("cfg off: %x , len %x\n",ST_SHORT_TEST_CFG_OFFSET,sizeof(st_short_test_cfg));
	TDU_CmdioWrite(2,ST_SHORT_TEST_CFG_OFFSET,st_short_test_cfg,sizeof(st_short_test_cfg));	
		
    	//#DoPower Down Wake Up    	
        buf[0] = 0x2;
        buf[1] = 0x2;        
        st_i2c_write_bytes(buf,2);
        
        msleep(150);
        buf[0] = 0x2;
        buf[1] = 0x0;
        st_i2c_write_bytes(buf,2);
        
        msleep(150);          
       
        WriteFilterRam();
        /////////////
	if(fSelectTXMode)  nTxStartRun= 0;
	for(nRun=nTxStartRun;(nRun<pMaxPatternCount)&&(fMayBeFilterRamError==false);nRun++)
	{
		
		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0x1D;  //Addr L
		pCMDData[5]= 0x02;  //Len
		pCMDData[6]= 0x2D;  //Data 0 
		pCMDData[7]= 0x2D; 		
		//ST1801_WriteCommandIO(pCMDData,8,false); 		
		TDU_CmdioWrite(4,0x1D,pCMDData+6,2);
		
		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0x28;  //Addr L
		pCMDData[5]= 0x02;  //Len
		pCMDData[6]= 0x24;  //Data 0 
        	pCMDData[7]= 0x00;  //Data 1
		//ST1801_WriteCommandIO(pCMDData,8,false);     
		TDU_CmdioWrite(4,0x28,pCMDData+6,2);

		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0x11;  //Addr L
		pCMDData[5]= 0x02;  //Len
		pCMDData[6]= 0x00;  //Data 0 
		pCMDData[7]= 0x00;  //Data 1
		//ST1801_WriteCommandIO(pCMDData,8,false); 
		TDU_CmdioWrite(4,0x11,pCMDData+6,2);
		
		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0x12;  //Addr L
		pCMDData[5]= 0x02;  //Len
		pCMDData[6]= 0x00;  //Data 0 
		pCMDData[7]= 0x00;  //Data 1
		//ST1801_WriteCommandIO(pCMDData,8,false);      
		TDU_CmdioWrite(4,0x12,pCMDData+6,2);
		
		//Set Addr :0x00D1 STOG[15:1]
		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0xD1;  //Addr L
		pCMDData[5]= 0x02;  //Len
		pCMDData[6]= Pattern[nRun][1];  //Data 0 
		pCMDData[7]= Pattern[nRun][0];  //Data 1
		//ST1801_WriteCommandIO(pCMDData,8,false);        
		TDU_CmdioWrite(4,0xD1,pCMDData+6,2);
		
		//Set Addr :0x00D2 STOG[31:16]
		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0xD2;  //Addr L
		pCMDData[5]= 0x02;  //Len
		pCMDData[6]= Pattern[nRun][3];  //Data 0 
		pCMDData[7]= Pattern[nRun][2];  //Data 1
		//ST1801_WriteCommandIO(pCMDData,8,false);     
		TDU_CmdioWrite(4,0xD2,pCMDData+6,2);

		//Set Addr :0x00D3 STOG[35:32] , OSB:10 <- 0.8uA
		pCMDData[0]= 0x01;
		pCMDData[1]= 0x07;
		pCMDData[2]= 0x04;  //Afe Reg = 4, Afe Mem = 3
		pCMDData[3]= 0x00;  //Addr H
		pCMDData[4]= 0xD3;  //Addr L
		pCMDData[5]= 0x02;  //Len                
		pCMDData[6]= 0x03;  //Data 0 
		if(fSelectTXMode){
			pCMDData[7]= ((Pattern[nRun][4] &0x0F)|(pTX_OSB<<4));  //Data 1
		}else{
			pCMDData[7]= ((Pattern[nRun][4] &0x0F)|(pRX_OSB<<4));  //Data 1
		}                
		//ST1801_WriteCommandIO(pCMDData,8,false);  
		sterr("Pattern0-3 %x %x %x %x,pCMDData[6][7] %x %x\n",Pattern[nRun][0],Pattern[nRun][1],Pattern[nRun][2],Pattern[nRun][3],pCMDData[6],pCMDData[7]);
		TDU_CmdioWrite(4,0xD3,pCMDData+6,2);		
				
		if(Get1DRaw(fSelectTXMode,pMutulRaw)<0)
		{ 
			sterr("Get1DRaw(fSelectTXMode,pMutulRaw) < 0 \n");
			nRet = -2;
                	return nRet;    
		}
	
		for(i=0;i<nScanChannel;i++)
		{
			//sterr("i %d ,nRun %d,nAddTx %d , pListArray[nRun][i+nAddTx] %d\n",i,nRun,nAddTx,pListArray[nRun][i+nAddTx]);
			nRaw =  pMutulRaw[i];  
			if(fSelectTXMode) nAddTx = 1;
			fFind=true;
			if(fSelectTXMode) nCheckStart =-1;
			if(pListArray[nRun][i+nAddTx]==0 && fFind)
			{
				//sterr("0000000000000000\n");
               	if((nRaw>nShortMaxRawDefine)&&( i>nCheckStart))
               	{
               		//sterr("1111111111111111\n");
					if(fSelectTXMode)
					{
						//sterr("22222222222\n");
						if(pShortSkipArray[i] !=0x01)
						{
							fFindShort = true;
							nRet = -1;
							if(nRaw>nMaxShortRecordRaw){
								nMaxShortRecordRaw = nRaw;
							}
						}
					 }
					 else
					 {					
						//sterr("333333333333\n");					
						if (pShortSkipArray[i] != 0x01) {
							stinf("i %d , raw %d\n",i,nRaw);
							if(nRaw>nMaxShortRecordRaw){
								nMaxShortRecordRaw = nRaw;
							}
							fFindShort=true;
							nRet = -1;
						}
					}
				}
			}
		}
	    stinf("short test result %d  nRun %d\n",nRet,nRun);
	}
	return nRet;
}

/*
	rtbuf is a u8 buf[X * Y + K]
	X:sensor count of X
	Y:sensor count of Y
	K:sensor count of K
	buf[?] = 0 means pass
	buf[?] = 1 means fail
	bug[20] means TX: 20/RX_count , RX: 20%RX_count
	RX_count : maybe X or Y , according layout..
	
	return : 
	<0 error
	0  success
	>0 failed sensor count
*/
int st_drv_test_raw(st_u8 *rtbuf,int length)
{	
	st_int result = 0;
	st_u8 buf[8];
	st_int sensorCount =0;
	st_int raw_J[MAX_SENSOR_COUNT];
	st_int tMode[4];
	st_int txr,rxr;	
#ifdef ST_RAWTEST_LOGFILE
	struct file *filp;
	char data1[50];
	mm_segment_t fs;
	
	filp = filp_open(ST_RAW_LOG_PATH, O_WRONLY|O_CREAT|O_TRUNC,0644);
	if(IS_ERR(filp))
	{
		sterr("ST open %s error...\n",ST_RAW_LOG_PATH);
		return -1;
	}
        
	fs=get_fs();
	set_fs(KERNEL_DS);
	filp->f_op->llseek(filp,0,0);
#endif
	
	memset(rtbuf,0,length);	
	stinf("start of st_drv_test_raw");	
	/////////////////////////////
	//check status
	memset(buf,0,8);
	result = st_i2c_read_bytes(1,buf,8);
	if(result <0)
	{
		sterr("ST I2C error (%d) \n",result);
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"ST I2C error (%d) \n",result);
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
		result = -1;	
		goto ST_RAW_CLOSE_FILE;
	}

	stinf("status :0x%X",buf[0]);
	if( (buf[0]&0xf) == 6)
	{
		sterr("ST IC in boot code , can't do test !\n");
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"ST IC in boot code , can't do test !\n");
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
		result = -1;
		goto ST_RAW_CLOSE_FILE;
	}
	
	////
	buf[0] = 0xF1;
	buf[1] = 0x40;
	st_i2c_write_bytes(buf,2);
	st_msleep(100);
	///////////////////////////////
	//get tmode
	st_i2c_read_bytes(0xF0,buf,1);	
	tMode[0] = (buf[0] & 0x04) >> 2;//tx is ?
	stinf("ST TX flag = %d\n",tMode[0]);
	st_i2c_read_bytes(0xF5,buf,3);
	tMode[1] = buf[0];	//x
	tMode[2] = buf[1];	//y
	tMode[3] = buf[2]&0xf;	// key

	sensorCount = tMode[1]+tMode[2]+tMode[3];

	stinf("sensor count:%d %d %d",tMode[1],tMode[2],tMode[3]);

	memset(rtbuf,0,tMode[1]*tMode[2]+tMode[3]);
	//////////////////////////////
	//get raw and judge
#ifdef ST_RAWTEST_LOGFILE
	result = st_drv_Get_2D_RAW(tMode,raw_J,0,rtbuf,filp);
#else
	result = st_drv_Get_2D_RAW(tMode,raw_J,0,rtbuf);
#endif
	if(result !=0)
	{
		sterr("Error: Test fail with %d sensor",result);			
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"Error: Test fail with %d sensor\n",result);
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
	} else {
	 
		stinf("Test open successed!\n");
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"Test open successed!\n");
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
		result =0;
	}
	//////////////////////////////
	//test short
	WriteTestCFG();
		
	rxr = RunFindShortStart(false,0x14, 0x24,3);
	if(rxr<0)
	{
		sterr("Error: Test Rx Short fail\n");			
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"Error: Test Rx Short fail\n");
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
		result++; 
	}
	
	txr = RunFindShortStart(true,0x14, 0x24,3);
	if(txr<0)
	{
		sterr("Error: Test Tx Short fail\n");			
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"Error: Test Tx Short fail\n");
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
		result++; 
	}
	if(rxr>=0 && txr >= 0)
	{
		stinf("Test short successed!\n");
#ifdef ST_RAWTEST_LOGFILE
		snprintf(data1,50,"Test short successed!\n");
		filp->f_op->write(filp, data1, strlen(data1),&filp->f_pos);
#endif
	}
	
	
	//st_irq_on();
	/////////////////////////////
	buf[0] = 2;
	buf[1] = 1;
	st_i2c_write_bytes(buf, 2);
	st_msleep(150);
ST_RAW_CLOSE_FILE:
	
#ifdef ST_RAWTEST_LOGFILE
	set_fs(fs);
  	filp_close(filp,NULL);  			
#endif
	//sterr("Test result file	: %s\n",ST_RAW_LOG_PATH);
	
	return result;
}


int st_testraw_invoke(void)
{
	st_u8 rtbuf[0x14*0x24];
	int length = sizeof(rtbuf)/sizeof(st_u8);
	return st_drv_test_raw(rtbuf,length);
}
#endif //ST_TEST_RAW
